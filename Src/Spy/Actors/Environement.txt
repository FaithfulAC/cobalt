--[[

    Wax environement replicated for actor env

]]

local RelayChannel = get_comm_channel(...)

local wax = { shared = {} }

for _, Service in pairs({
	"Players",
}) do
	wax.shared[Service] = cloneref(game:GetService(Service))
end

wax.shared.LocalPlayer = wax.shared.Players.LocalPlayer
wax.shared.PlayerScripts = wax.shared.LocalPlayer:WaitForChild("PlayerScripts")
wax.shared.ExecutorName = string.split(identifyexecutor(), " ")[1]

wax.shared.newcclosure = wax.shared.ExecutorName == "AWP"
		and function(f)
			local env = getfenv(f)
			local x = setmetatable({
				__F = f,
			}, {
				__index = env,
				__newindex = env,
			})

			local nf = function(...)
				return __F(...)
			end
			setfenv(nf, x) -- set func env (env of nf gets deoptimized)
			return newcclosure(nf)
		end
	or newcclosure

wax.shared.restorefunction = function(Function: (...any) -> ...any, Silent: boolean?)
	local Original = wax.shared.Hooks[Function]

	if Silent and not Original then
		return
	end

	assert(Original, "Function not hooked")

	if restorefunction and isfunctionhooked(Function) then
		restorefunction(Function)
	else
		hookfunction(Function, Original)
	end

	wax.shared.Hooks[Function] = nil
end

wax.shared.Hooks = {}
wax.shared.Settings = {
	IgnorePlayerModule = { Value = CobaltDynamicValue_IgnorePlayerModule },
	IgnoredRemotesDropdown = { Value = CobaltDynamicValue_IgnoredRemotesDropdown },
}

wax.shared.IsPlayerModule = function(Origin: LocalScript | ModuleScript)
	local PlayerModule = Origin and Origin.FindFirstAncestor(Origin, "PlayerModule") or nil
	return PlayerModule and PlayerModule.Parent == wax.shared.PlayerScripts
end
wax.shared.ShouldIgnore = function(Instance, Origin)
	return wax.shared.Settings.IgnoredRemotesDropdown.Value[Instance.ClassName] == true
		or (wax.shared.Settings.IgnorePlayerModule.Value and wax.shared.IsPlayerModule(Origin))
end

local OnUnload

local RelayConnection
RelayConnection = RelayChannel.Event:Connect(function(Type, ...)
	if Type == "Unload" then
		RelayConnection:Disconnect()
		wax.shared.Unloaded = true

		if OnUnload then
			OnUnload()
		end
	elseif Type == "MainBlock" then
		local Instance, EventType = ...
		local Log = wax.shared.Logs[EventType][Instance]
		if Log then
			Log:Block()
		end
	elseif Type == "MainIgnore" then
		local Instance, EventType = ...
		local Log = wax.shared.Logs[EventType][Instance]
		if Log then
			Log:Ignore()
		end
	elseif Type == "MainSettingsSync" then
		local Setting, Value = ...
		if wax.shared.Settings[Setting] then
			wax.shared.Settings[Setting].Value = Value
		end
	end
end)

wax.shared.Unloaded = false
wax.shared.Communicator = RelayChannel

wax.shared.Log = {}
do
	local Log = wax.shared.Log
	Log.__index = Log

	function Log.new(Instance, Type, Method, Index, CallingScript)
		local NewLog = setmetatable({
			Instance = Instance,
			Type = Type,
			Method = Method,
			Index = Index,
			Calls = {},
			Ignored = false,
			Blocked = false,
		}, Log)

		return NewLog
	end

	function Log:Call(Info)
		local Data = {
			Arguments = Info[1],
			Time = Info[2],
			Origin = Info[3],
			Function = Info[4],
			Line = Info[5],
			IsExecutor = Info[6],
		}

		if Info[7] then
			Data.OriginalInvokeArgs = Info[7]
		end

		wax.shared.Communicator.Fire(wax.shared.Communicator, "ActorCall", self.Instance, self.Type, Data)
	end

	function Log:Ignore()
		self.Ignored = not self.Ignored
	end

	function Log:Block()
		self.Blocked = not self.Blocked
	end
end

wax.shared.Logs = {
	Outgoing = {},
	Incoming = {},
}

wax.shared.NewLog = function(Instance, Type, Method, Index, CallingScript)
	local NewLog = wax.shared.Log.new(Instance, Type, Method, Index, CallingScript)
	wax.shared.Logs[Type][Instance] = NewLog
	return NewLog
end
