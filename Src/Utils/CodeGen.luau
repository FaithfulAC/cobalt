local CodeGen = {
	CleanTable = { ['"'] = '\\"', ["\\"] = "\\\\" },
}

type SupportedRemoteTypes = RemoteEvent | RemoteFunction | BindableEvent | BindableFunction | UnreliableRemoteEvent
type CallInfo = {
	Arguments: { any },
	Time: string,
	Origin: BaseScript?,
	Function: (...any) -> any,
	Line: number?,
	Instance: SupportedRemoteTypes,
	Order: number,
	OriginalInvokeArgs: { any }?,
}

wax.shared.FunctionForClasses = {
	Incoming = {
		RemoteEvent = "OnClientEvent",
		RemoteFunction = "OnClientInvoke",
		UnreliableRemoteEvent = "OnClientEvent",
		BindableEvent = "Event",
		BindableFunction = "OnInvoke",
	},

	Outgoing = {
		RemoteEvent = "FireServer",
		RemoteFunction = "InvokeServer",
		UnreliableRemoteEvent = "FireServer",
		BindableEvent = "Fire",
		BindableFunction = "Invoke",
	},
}

local GetNilCode = [[local function GetNil(Name, DebugId)
	for _, Object in pairs(getnilinstances()) do
		if Object.Name == Name and Object:GetDebugId() == DebugId then
			return Object
		end
	end
end]]

--// Pasted from Dex (maximum detection)
for i = 0, 31 do
	CodeGen.CleanTable[string.char(i)] = "\\" .. string.format("%03d", i)
end
for i = 127, 255 do
	CodeGen.CleanTable[string.char(i)] = "\\" .. string.format("%03d", i)
end

function CodeGen.FormatLuaString(str)
	return string.gsub(str, '["\\\0-\31\127-\255]', CodeGen.CleanTable)
end

function CodeGen.GetFullPath(Object, ExcludeCode, VariableName)
	local CurrentObject = Object
	local IsNil = false
	local Path = ""

	repeat
		if typeof(CurrentObject) ~= "Instance" then
			break
		end

		if CurrentObject == game then
			Path = "game" .. Path
			break
		end

		local IndexName = ""

		if CurrentObject == wax.shared.LocalPlayer then
			IndexName = ".LocalPlayer"
		elseif wax.shared.LocalPlayer.Character and CurrentObject == wax.shared.LocalPlayer.Character then
			IndexName = 'game:GetService("Players").LocalPlayer.Character'
		elseif CurrentObject.Name and CurrentObject.Name == wax.shared.LocalPlayer.Name then
			IndexName = '[game:GetService("Players").LocalPlayer.Name]'
		elseif CurrentObject.Name and CurrentObject.Name == tostring(wax.shared.LocalPlayer.UserId) then
			IndexName = '[game:GetService("Players").LocalPlayer.UserId]'
		elseif CurrentObject.ClassName then
			if string.match(CurrentObject.Name, "^[%a_][%w_]*$") then
				IndexName = "." .. CurrentObject.Name
			else
				IndexName = '["' .. CodeGen.FormatLuaString(CurrentObject.Name) .. '"]'
			end

			local Parent = CurrentObject.Parent
			if Parent then
				if Parent == workspace then
					Path = "workspace" .. Path
					break
				elseif Parent == game and game.FindService(game, CurrentObject.ClassName) == CurrentObject then
					IndexName = ':GetService("' .. CurrentObject.ClassName .. '")'
				end
			elseif Parent == nil then
				IsNil = true

				if ExcludeCode then
					Path = Path .. " --[[Nil Parent]]"
				else
					Path = GetNilCode
						.. `\n\n{VariableName and `local {VariableName} = ` or ""}GetNil("{CurrentObject.Name}", "{CurrentObject:GetDebugId()}")`
					break
				end
			end
		end

		Path = IndexName .. Path

		if wax.shared.LocalPlayer.Character and CurrentObject == wax.shared.LocalPlayer.Character then
			break
		end

		CurrentObject = CurrentObject.Parent
	until CurrentObject == nil

	if IsNil then
		return Path
	end

	return `{VariableName and `local {VariableName} = ` or ""}{Path}`
end

local function DoesUseCallbackValue(Instance: Instance)
	return Instance.ClassName == "RemoteFunction" or Instance.ClassName == "BindableFunction"
end

local CodeGenHeader = [[-- This code was generated by Cobalt
-- https://github.com/notpoiu/cobalt

]]

function CodeGen:BuildCallCode(CallInfo: CallInfo, Type: "Incoming" | "Outgoing")
	local Path = self.GetFullPath(CallInfo.Instance, false, "Event")
	local Method = wax.shared.FunctionForClasses[Type][CallInfo.Instance.ClassName]
	local SerializedArgs =
		`table.unpack({wax.shared.LuaEncode(CallInfo.Arguments, { Prettify = true, InsertCycles = true })})`
	local IsArgsEmpty = wax.shared.GetTableLength(CallInfo.Arguments) == 0

	if IsArgsEmpty then
		SerializedArgs = ""
	end

	if Type == "Incoming" then
		if DoesUseCallbackValue(CallInfo.Instance) then
			if CallInfo.OriginalInvokeArgs then
				SerializedArgs = `table.unpack({wax.shared.LuaEncode(
					CallInfo.OriginalInvokeArgs,
					{ Prettify = true, InsertCycles = true }
				)})`
				Method = wax.shared.FunctionForClasses.Outgoing[CallInfo.Instance.ClassName]

				return string.format(
					[[%s%s
local Result = Event:%s(%s)]],
					CodeGenHeader,
					Path,
					Method,
					SerializedArgs
				)
			end

			return string.format(
				[[%s%s
local Callback = getcallbackvalue(Event, "%s")

Callback(%s)]],
				CodeGenHeader,
				Path,
				Method,
				SerializedArgs
			)
		end

		return string.format(
			[[%s%s
firesignal(Event.%s%s)]],
			CodeGenHeader,
			Path,
			Method,
			IsArgsEmpty and "" or `, {SerializedArgs}`
		)
	end

	return string.format(
		[[%s%s
Event:%s(%s)]],
		CodeGenHeader,
		Path,
		Method,
		SerializedArgs
	)
end

function CodeGen:BuildFunctionInfo(CallInfo: CallInfo)
	local FunctionName = debug.info(CallInfo.Function, "n")

	return string.format(
		[[<b>Function Address:</b> %s
<b>Name:</b> %s
<b>Source:</b> %s
<b>Calling Line:</b> %s
%s]],
		tostring(CallInfo.Function):match("0x%x+") or tostring(CallInfo.Function),
		FunctionName ~= "" and FunctionName or "Anonymous",
		CallInfo.Origin and self.GetFullPath(CallInfo.Origin, true) or wax.shared.ExecutorName,
		tostring(CallInfo.Line),

		iscclosure(CallInfo.Function) and "<b>Closure Type</b>: C closure"
			or string.format(
				"<b>Closure Type</b>: Luau closure\n<b>Constants:</b> %s\n<b>Upvalues:</b> %s\n<b>Protos:</b> %s",
				debug.getconstants and tostring(#debug.getconstants(CallInfo.Function)) or "N/A",
				debug.getupvalues and tostring(#debug.getupvalues(CallInfo.Function)) or "N/A",
				debug.getprotos and tostring(#debug.getprotos(CallInfo.Function)) or "N/A"
			)
	)
end

wax.shared.ReplayCallInfo = function(CallInfo: CallInfo, Type: "Incoming" | "Outgoing")
	local Method = wax.shared.FunctionForClasses[Type][CallInfo.Instance.ClassName]

	if Type == "Incoming" then
		if DoesUseCallbackValue(CallInfo.Instance) then
			local Callback = getcallbackvalue(CallInfo.Instance, Method)

			if not Callback then
				return
			end

			Callback(table.unpack(CallInfo.Arguments))
			return
		end

		assert(firesignal or getconnections, "No firesignal or getconnections found")

		if firesignal then
			firesignal(CallInfo.Instance[Method], table.unpack(CallInfo.Arguments))
		elseif getconnections then
			for _, conn in getconnections(CallInfo.Instance[Method]) do
				conn:Fire(table.unpack(CallInfo.Arguments))
			end
		end

		return
	end

	CallInfo.Instance[Method](CallInfo.Instance, table.unpack(CallInfo.Arguments))
end

return CodeGen
